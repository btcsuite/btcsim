/*
 * Copyright (c) 2014-2015 Conformal Systems LLC <info@conformal.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package simnode

import (
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"

	rpc "github.com/btcsuite/btcrpcclient"
	"github.com/btcsuite/btcutil"
)

// ErrConnectionTimeOut is raised when a rpc Client is unable to connect
// to the node within maxConnRetries * 50ms
var ErrConnectionTimeOut = errors.New("connection timeout")

// Args is an interface which specifies how to access all the data required
// to launch and connect to a RPC server, typically btcd or btcwallet
type Args interface {
	Arguments() []string
	Command() *exec.Cmd
	RPCConnConfig() rpc.ConnConfig
	Cleanup() error
	fmt.Stringer
}

// Node is a RPC server node, typically btcd or btcwallet and functions to
// manage the instance
// All functions common to btcd and btcwallet go here while btcdArgs and
// btcwalletArgs hold the different implementations
type Node struct {
	Args
	Handlers       *rpc.NotificationHandlers
	Client         *rpc.Client
	cmd            *exec.Cmd
	pidFile        string
	dataDir        string
	maxConnRetries int
}

// NewNodeFromArgs starts a new node using the args provided, sets the handlers
// and loggers. It does not start the node process, Start() should be called for that
func NewNodeFromArgs(args Args, handlers *rpc.NotificationHandlers, w io.Writer, maxRetries int, dataDir string) (*Node, error) {
	n := Node{
		Args:           args,
		Handlers:       handlers,
		maxConnRetries: maxRetries,
		dataDir:        dataDir,
	}
	cmd := n.Command()
	n.cmd = cmd
	if w != nil {
		n.cmd.Stdout = w
		n.cmd.Stderr = w
	}
	return &n, nil
}

// Start stats the node command
// It writes a pidfile to AppDataDir with the name of the process
// which can be used to terminate the process in case of a hang or panic
func (n *Node) Start() error {
	if err := n.cmd.Start(); err != nil {
		return err
	}
	pid, err := os.Create(filepath.Join(n.dataDir,
		fmt.Sprintf("%s.pid", n.Args)))
	if err != nil {
		return err
	}
	n.pidFile = pid.Name()
	if _, err = fmt.Fprintf(pid, "%d\n", n.cmd.Process.Pid); err != nil {
		return err
	}
	if err := pid.Close(); err != nil {
		return err
	}
	return nil
}

// Connect tries to connect to the launched node and sets the
// Client field. It returns an error if the connection times out
func (n *Node) Connect() error {
	var client *rpc.Client
	var err error

	rpcConf := n.RPCConnConfig()

	for i := 0; i < n.maxConnRetries; i++ {
		if client, err = rpc.New(&rpcConf, n.Handlers); err != nil {
			time.Sleep(time.Duration(i) * 50 * time.Millisecond)
			continue
		}
		break
	}
	if client == nil {
		return ErrConnectionTimeOut
	}
	n.Client = client
	return nil
}

// Stop interrupts a process and waits until it exits
// On windows, interrupt is not supported, so a kill
// signal is used instead
func (n *Node) Stop() error {
	if n.cmd == nil || n.cmd.Process == nil {
		// return if not properly initialized
		// or error starting the process
		return nil
	}
	defer n.cmd.Wait()
	if runtime.GOOS == "windows" {
		return n.cmd.Process.Signal(os.Kill)
	}
	return n.cmd.Process.Signal(os.Interrupt)
}

// Cleanup cleanups process and args files
func (n *Node) Cleanup() error {
	if n.pidFile != "" {
		if err := os.Remove(n.pidFile); err != nil {
			log.Printf("Cannot remove file %s: %v", n.pidFile, err)
		}
	}
	return n.Args.Cleanup()
}

// Shutdown stops a node and cleansup
func (n *Node) Shutdown() {
	if n.Client != nil {
		n.Client.Shutdown()
	}
	if err := n.Stop(); err != nil {
		log.Printf("%s: Cannot stop node: %v", n, err)
	}
	if err := n.Cleanup(); err != nil {
		log.Printf("%s: Cannot cleanup: %v", n, err)
	}
	log.Printf("%s: Shutdown", n)
}

// GenCertPair generates a key/cert pair to the paths provided.
func GenCertPair(certFile, keyFile string) error {
	org := "btcsim autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0666); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	return nil
}
